diff --git a/src/mercury.c b/src/mercury.c
index 4101ffe..a485c12 100644
--- a/src/mercury.c
+++ b/src/mercury.c
@@ -26,7 +26,7 @@
 /* Local Macros */
 /****************/
 
-#define HG_POST_LIMIT_DEFAULT 256
+#define HG_POST_LIMIT_DEFAULT 2048
 
 #define HG_CONTEXT_CLASS(context) \
     ((struct hg_private_class *)(context->hg_class))
diff --git a/src/na/CMakeLists.txt b/src/na/CMakeLists.txt
index b6ca33a..bf5aae5 100644
--- a/src/na/CMakeLists.txt
+++ b/src/na/CMakeLists.txt
@@ -50,7 +50,7 @@ set(NA_BUILD_INCLUDE_DEPENDENCIES
 #include_directories(${MERCURY_UTIL_EXT_INCLUDE_DEPENDENCIES})
 
 # Multi progress
-option(NA_ALLOW_MULTI_PROGRESS "Allow concurrent progress on single context." ON)
+option(NA_ALLOW_MULTI_PROGRESS "Allow concurrent progress on single context." OFF)
 if(NA_ALLOW_MULTI_PROGRESS)
   set(NA_HAS_MULTI_PROGRESS 1)
 endif()
diff --git a/src/na/na_ofi.c b/src/na/na_ofi.c
index 16534f5..a327831 100644
--- a/src/na/na_ofi.c
+++ b/src/na/na_ofi.c
@@ -194,13 +194,13 @@ static unsigned long const na_ofi_prov_flags[] = { NA_OFI_PROV_TYPES };
 
 /* Memory pool (enabled by default, comment out to disable) */
 #define NA_OFI_HAS_MEM_POOL
-#define NA_OFI_MEM_BLOCK_COUNT          (256)
+#define NA_OFI_MEM_BLOCK_COUNT          (2048)
 
 /* Max tag */
 #define NA_OFI_MAX_TAG                  UINT32_MAX
 
 /* Unexpected size */
-#define NA_OFI_UNEXPECTED_SIZE          (4096)
+#define NA_OFI_UNEXPECTED_SIZE          (8192)
 #define NA_OFI_UNEXPECTED_TAG           (0x100000000ULL)
 #define NA_OFI_TAG_MASK                 (0xFFFFFFFFULL)
 
@@ -411,6 +411,7 @@ struct na_ofi_class {
     na_uint8_t max_contexts;                /* Max number of contexts   */
     na_bool_t no_wait;                      /* Ignore wait object       */
     na_bool_t no_retry;                     /* Do not retry operations  */
+    na_size_t block_size;                   /* Node block size          */
 };
 
 /********************/
@@ -2301,15 +2302,21 @@ na_ofi_addr_decref(struct na_ofi_addr *na_ofi_addr)
     free(na_ofi_addr);
 }
 
+#define MEM_POOL_ALIGN	1
+
 /*---------------------------------------------------------------------------*/
 static struct na_ofi_mem_pool *
 na_ofi_mem_pool_create(na_class_t *na_class, na_size_t block_size,
     na_size_t block_count)
 {
     struct na_ofi_mem_pool *na_ofi_mem_pool = NULL;
+#if MEM_POOL_ALIGN
+    na_size_t pool_size = block_size * (block_count + 1);
+#else
     na_size_t pool_size = block_size * block_count
         + sizeof(struct na_ofi_mem_pool)
         + block_count * (offsetof(struct na_ofi_mem_node, block));
+#endif
     struct fid_mr *mr_hdl = NULL;
     na_size_t i;
 
@@ -2326,9 +2333,15 @@ na_ofi_mem_pool_create(na_class_t *na_class, na_size_t block_size,
     /* Assign nodes and insert them to free list */
     for (i = 0; i < block_count; i++) {
         struct na_ofi_mem_node *na_ofi_mem_node =
+#if MEM_POOL_ALIGN /* NB: header consumes 1 block as well */
+            (struct na_ofi_mem_node *)((char *)na_ofi_mem_pool +
+			    (i + 2) * block_size -
+			    sizeof(struct na_ofi_mem_node));
+#else
             (struct na_ofi_mem_node *) ((char *) na_ofi_mem_pool
                 + sizeof(struct na_ofi_mem_pool)
                 + i * (offsetof(struct na_ofi_mem_node, block) + block_size));
+#endif
         HG_QUEUE_PUSH_TAIL(&na_ofi_mem_pool->node_list, na_ofi_mem_node, entry);
     }
 
@@ -2439,7 +2452,11 @@ retry:
     }
     HG_QUEUE_POP_HEAD(&na_ofi_mem_pool->node_list, entry);
     hg_thread_spin_unlock(&na_ofi_mem_pool->node_list_lock);
+#if MEM_POOL_ALIGN
+    mem_ptr = (char *)&na_ofi_mem_node[1] - na_ofi_mem_pool->block_size;
+#else
     mem_ptr = &na_ofi_mem_node->block;
+#endif
     *mr_hdl = na_ofi_mem_pool->mr_hdl;
 
 out:
@@ -2451,8 +2468,13 @@ static void
 na_ofi_mem_pool_free(na_class_t *na_class, void *mem_ptr, struct fid_mr *mr_hdl)
 {
     struct na_ofi_mem_pool *na_ofi_mem_pool;
+#if MEM_POOL_ALIGN
+    struct na_ofi_mem_node *na_ofi_mem_node =
+	    ((struct na_ofi_mem_node *)&mem_ptr[NA_OFI_CLASS(na_class)->block_size]) - 1;
+#else
     struct na_ofi_mem_node *na_ofi_mem_node =
         container_of(mem_ptr, struct na_ofi_mem_node, block);
+#endif
 
     /* Put the node back to the pool */
     hg_thread_spin_lock(&NA_OFI_CLASS(na_class)->buf_pool_lock);
@@ -3159,6 +3181,7 @@ na_ofi_initialize(na_class_t *na_class, const struct na_info *na_info,
     ret = na_ofi_get_ep_addr(na_class, &priv->endpoint->src_addr);
     NA_CHECK_NA_ERROR(out, ret, "Could not get address from endpoint");
 
+    priv->block_size = na_ofi_msg_get_max_unexpected_size(na_class);
 out:
     if (ret != NA_SUCCESS) {
         if (na_class->plugin_class) {
diff --git a/src/util/mercury_mem.c b/src/util/mercury_mem.c
index eb48187..44fb689 100644
--- a/src/util/mercury_mem.c
+++ b/src/util/mercury_mem.c
@@ -28,14 +28,18 @@
 long
 hg_mem_get_page_size(void)
 {
-    long page_size;
 
 #ifdef _WIN32
+    long page_size;
+
     SYSTEM_INFO system_info;
     GetSystemInfo (&system_info);
     page_size = system_info.dwPageSize;
 #else
-    page_size = sysconf(_SC_PAGE_SIZE);
+    static long page_size;
+
+    if (page_size == 0)
+         page_size = sysconf(_SC_PAGE_SIZE);
 #endif
 
     return page_size;
diff --git a/src/util/mercury_time.h b/src/util/mercury_time.h
index 7055a35..1f71d2a 100644
--- a/src/util/mercury_time.h
+++ b/src/util/mercury_time.h
@@ -203,7 +203,7 @@ hg_time_get_current(hg_time_t *tv)
 {
     struct timespec tp = {0, 0};
     /* NB. CLOCK_MONOTONIC_RAW is not explicitly supported in the vdso */
-    clockid_t clock_id = CLOCK_MONOTONIC;
+    clockid_t clock_id = CLOCK_MONOTONIC_COARSE;
 
     if (!tv)
         return HG_UTIL_FAIL;
